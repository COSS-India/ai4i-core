<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Casbin RBAC with Domains</title>
    <style>
        /* CRITICAL: Force all colors to print */
        * {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
            color-adjust: exact !important;
        }
        
        html {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
            color-adjust: exact !important;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
            color-adjust: exact !important;
        }
        
        /* Print reminder banner - will be hidden when printing */
        .print-reminder {
            background: #ffeb3b;
            border: 2px solid #fbc02d;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }
        
        h1 {
            color: #000;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }
        
        h2, h3, h4 {
            color: #000;
        }
        
        code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        /* Print media query - CRITICAL for PDF export */
        @media print {
            .print-reminder {
                display: none !important;
            }
            
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                color-adjust: exact !important;
            }
            
            html, body {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                color-adjust: exact !important;
                background: white !important;
            }
            
            body {
                margin: 0;
                padding: 15px;
            }
            
            @page {
                margin: 1.5cm;
                size: A4;
            }
            
            /* Force background colors on all divs */
            div {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                color-adjust: exact !important;
                page-break-inside: avoid;
                break-inside: avoid;
            }
            
            /* Ensure all styled divs keep their colors */
            div[style*="background-color"] {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                color-adjust: exact !important;
            }
        }
    </style>
</head>
<body>
    <div class="print-reminder">
        ⚠️ IMPORTANT: When printing, click "More settings" and check "Background graphics" to see colors in PDF!
    </div>
# Casbin RBAC with Domains (Users and API Keys)

This document describes how to apply Casbin-based RBAC with domain (tenant) isolation for both user and API-key authentication in this project. It covers the model, validation flows, and two simple architecture diagrams (user-level and API-key-level enforcement).

<div style="background-color: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin: 20px 0; border-radius: 5px;">

## Executive summary 
- Casbin is our central permission engine: every request is checked here.
- Domains = tenants; all checks are tenant-scoped to keep orgs isolated.
- **Users** use role-based access (assigned roles, roles have permissions).
- **API keys** use direct permissions (permissions assigned directly, no roles needed).
- Service access (ASR/TTS/NMT inference) requires API keys — users cannot access services directly.
- Each request is checked on: who/what calls, which tenant, which resource, and what action.

</div>

<div style="background-color: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin: 20px 0; border-radius: 5px;">

### Plain-language validation rule
“Given who/what is calling, which tenant they’re in, the resource they want, and the action they want to perform, Casbin decides if it’s allowed for that tenant. If allowed, the request proceeds; otherwise it’s blocked and logged.”

**Service access note:** ASR/TTS/NMT (and any inference-like actions) require an API key. User roles do **not** get inference permissions; users can manage services/models (create/delete/get) but cannot call inference without an API key.

</div>

<div style="background-color: #f3e5f5; border-left: 4px solid #9c27b0; padding: 15px; margin: 20px 0; border-radius: 5px;">

### What changes for us
- One central policy store (casbin_rule) instead of scattered checks.
- Consistent enforcement for all services and for API keys and users.
- Tenant isolation by default via the domain in every request and policy.
- Clear audit trail: every allow/deny is decided in one place.

</div>

<div style="background-color: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px; margin: 20px 0; border-radius: 5px;">

### Rollout plan (high level)
- Wire Casbin middleware in services (enforcer call per protected route).
- Populate policies/role bindings in the DB adapter (per tenant).
- Enable cache + watcher (e.g., Redis) for live policy updates.
- Add basic allow/deny logging for audit and troubleshooting.

</div>

<div style="background-color: #fce4ec; border: 2px solid #e91e63; padding: 20px; margin: 20px 0; border-radius: 8px;">

## Use Cases and Advantages

### Use Cases

1. **Multi-tenant SaaS applications**
   - Isolate permissions per tenant/workspace automatically
   - Prevent cross-tenant data access
   - Support different permission models per tenant

2. **Unified authorization for users and API keys**
   - Same permission engine for both authentication methods
   - Consistent security model across all access types
   - Easier to audit and manage

3. **Dynamic permission management**
   - Update permissions without code changes
   - Add/remove roles and permissions in real-time
   - Support complex role hierarchies (admin → moderator → user)

4. **Service-to-service authorization**
   - API keys can have fine-grained permissions (e.g., only ASR inference, not TTS)
   - Support different permission levels per service
   - Enable service-specific access controls

5. **Compliance and audit requirements**
   - Centralized decision logging
   - Complete audit trail of who accessed what and when
   - Easy to generate compliance reports

### Advantages

1. **Centralized policy management**
   - Single source of truth for all permissions
   - No scattered permission checks across codebase
   - Easier to maintain and update

2. **Performance and scalability**
   - Efficient policy evaluation with caching
   - Fast permission checks (milliseconds)
   - Scales to thousands of policies and users

3. **Flexibility and extensibility**
   - Easy to add new resources and actions
   - Support complex permission models (RBAC, ABAC, etc.)
   - Can evolve permission model without major refactoring

4. **Security benefits**
   - Tenant isolation by design (domain-based)
   - Consistent enforcement prevents security gaps
   - Reduces risk of permission bypass bugs

5. **Developer experience**
   - Simple API: `enforce(subject, domain, object, action)`
   - Clear separation of concerns (auth vs. authorization)
   - Easy to test and debug

6. **Operational benefits**
   - Real-time policy updates without service restarts
   - Policy changes take effect immediately via watcher
   - Reduced deployment frequency for permission changes

7. **Cost savings**
   - Less code to maintain (no custom permission logic)
   - Faster development of new features
   - Reduced security review time

</div>

<div style="background-color: #e0f2f1; border: 2px solid #009688; padding: 20px; margin: 20px 0; border-radius: 8px;">

## Casbin Model (RBAC with Domain)
```
[request_definition]
r = sub, dom, obj, act

[policy_definition]
p = sub, dom, obj, act

[role_definition]
g = sub, dom, role
g2 = role, dom, role   # optional hierarchy

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, r.dom, p.sub) && r.dom == p.dom && r.obj == p.obj && r.act == p.act
    || r.sub == p.sub && r.dom == p.dom && r.obj == p.obj && r.act == p.act
    || g2(p.sub, p.dom, r.obj)  # optional if using role→role nesting
```

Key concepts:
- `sub` (subject): `user:{id}` for end-users, `api_key:{id}` for API keys.
- `dom` (domain): tenant/workspace/org identifier.
- `obj` (object): resource (users, configurations, dashboards, alerts, metrics, asr, tts, nmt, etc.).
- `act` (action): create, read, update, delete, inference, export.

</div>

<div style="background-color: #fff9c4; border: 3px solid #fbc02d; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">

## Architecture (User-Level Enforcement)
```mermaid
flowchart LR
  A[Client] --> B[AuthN]
  B --> C[Context sub=user_id dom=tenant_id]
  C --> D[Route mapper obj act]
  D --> E[Casbin enforcer]
  subgraph Casbin
    E --> F[Model]
    E --> G[Adapter casbin_rule]
    E --> H[Watcher Redis]
  end
  E --> I[Service handler]
```

<div style="background-color: #ffebee; border-left: 5px solid #f44336; padding: 10px; margin: 15px 0; border-radius: 4px;">

**Validation Flow:** `userId → roles → permissions → allowed? deny?`

</div>

### Validation Rules

**Process:**
1. Extract `user_id` and `tenant_id` from JWT token
2. Lookup user's roles: `g(user_id, tenant_id, role)` → returns list of roles
3. For each role, check permissions: `p(role, tenant_id, object, action)`
4. If any role has the permission → **ALLOWED**
5. If no role has the permission → **DENIED**

**Example:**
- User `alice` in `tenantA` has role `admin` (`g, user:alice, tenantA, admin`)
- Role `admin` has permission `p, admin, tenantA, users, read`
- Request: `(user:alice, tenantA, users, read)` → **ALLOWED**

### Summary 
- User signs in and gets a token that says who they are and which tenant they belong to.  
- System looks up which roles the user has in that tenant.  
- System checks if those roles have the required permission for the resource and action.  
- If allowed, the request goes through; otherwise it is blocked and recorded.

</div>

<div style="background-color: #e1f5fe; border: 3px solid #03a9f4; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">

## Architecture (API-Key-Level Enforcement)
```mermaid
flowchart LR
  A[Client with API key] --> B[API key validator]
  B --> C[Context sub=api_key_id dom=tenant_id]
  C --> D[Route mapper obj act]
  D --> E[Casbin enforcer]
  subgraph Casbin
    E --> F[Model]
    E --> G[Adapter casbin_rule]
    E --> H[Watcher Redis]
  end
  E --> I[Service handler]
```

<div style="background-color: #e8f5e9; border-left: 5px solid #4caf50; padding: 10px; margin: 15px 0; border-radius: 4px;">

**Validation Flow:** `api-key → permissions → allowed? deny?`

</div>

### Validation Rules

**Process:**
1. Validate API key (hash, active, not expired) → get `api_key_id` and `tenant_id`
2. Check direct permissions: `p(api_key_id, tenant_id, object, action)` — no roles needed
3. If permission exists → **ALLOWED**
4. If permission does not exist → **DENIED**

**Example:**
- API key `api_key_1` has permission `p, api_key_1, tenantA, users, read`
- Request: `(api_key_1, tenantA, users, read)` → **ALLOWED**
- Request: `(api_key_1, tenantA, users, create)` → **DENIED** (no such permission)

### Summary
- The API key is checked to ensure it exists, is active, and belongs to the right tenant.  
- System directly checks if the API key has the required permission (no role lookup needed).  
- Each permission is directly assigned to the API key.  
- If allowed, the request proceeds; otherwise it is blocked and logged.

</div>

<div style="background-color: #f1f8e9; border: 2px solid #8bc34a; padding: 20px; margin: 20px 0; border-radius: 8px;">

## Policy Examples

### Format
- **User policies (role-based):** `p, role, domain, object, action`
- **API key policies (direct):** `p, api_key_id, domain, object, action`
- **Role bindings:** `g, user_id, domain, role`

<div style="background-color: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin: 15px 0; border-radius: 5px;">

### User-Level Policies (Role-Based)
**Admin role policies (tenant `tenantA`):**
- `p, admin, tenantA, users, create`
- `p, admin, tenantA, users, read`
- `p, admin, tenantA, users, update`
- `p, admin, tenantA, users, delete`
- `p, admin, tenantA, users, search`
- `p, admin, tenantA, configurations, create`
- `p, admin, tenantA, configurations, read`
- `p, admin, tenantA, configurations, update`
- `p, admin, tenantA, configurations, delete`
- `p, admin, tenantA, metrics, read`
- `p, admin, tenantA, metrics, export`
- `p, admin, tenantA, alerts, create`
- `p, admin, tenantA, alerts, read`
- `p, admin, tenantA, alerts, update`
- `p, admin, tenantA, alerts, delete`
- `p, admin, tenantA, dashboards, create`
- `p, admin, tenantA, dashboards, read`
- `p, admin, tenantA, dashboards, update`
- `p, admin, tenantA, dashboards, delete`

**User role policies (read-only example):**
- `p, user, tenantA, users, read`
- `p, user, tenantA, users, search`
- `p, user, tenantA, configurations, read`
- `p, user, tenantA, dashboards, read`
- `p, user, tenantA, alerts, read`
- `p, user, tenantA, metrics, read`

**Role bindings (assign users to roles):**
- `g, user:alice, tenantA, admin`
- `g, user:bob, tenantA, user`

</div>

<div style="background-color: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin: 15px 0; border-radius: 5px;">

### API-Key-Level Policies (Direct Permissions)
**Service access (ASR/TTS/NMT) is API-key only — direct permissions:**

Example API key 1:
- `p, api_key_1, tenantA, users, read`
- `p, api_key_1, tenantA, users, search`
- `p, api_key_1, tenantA, asr, read`
- `p, api_key_1, tenantA, asr, inference`
- `p, api_key_1, tenantA, tts, read`

Example API key 2:
- `p, api_key_2, tenantA, users, create`
- `p, api_key_2, tenantA, users, read`
- `p, api_key_2, tenantA, nmt, read`
- `p, api_key_2, tenantA, nmt, inference`

**Note:** API keys use direct permissions — each permission is explicitly assigned to the API key. No roles needed.

</div>

<div style="background-color: #f3e5f5; border-left: 4px solid #9c27b0; padding: 15px; margin: 15px 0; border-radius: 5px;">

Optional role hierarchy (if you introduce moderator/user tiers):
- `g2, admin, tenantA, moderator`
- `g2, moderator, tenantA, user`

### Important Rules
- **Service access (ASR/TTS/NMT):** Requires API key — users cannot access services directly, only via API keys.
- Always include `dom` (tenant) in requests and policies to ensure tenant isolation.
- Users go through roles; API keys use direct permissions (no roles).

</div>

<div style="background-color: #fce4ec; border: 2px solid #e91e63; padding: 20px; margin: 20px 0; border-radius: 8px;">

## Testing Guide

<div style="background-color: #fff9c4; border-left: 5px solid #fbc02d; padding: 15px; margin: 15px 0; border-radius: 5px;">

### What Needs to Be Tested

The Casbin RBAC system needs to be tested to ensure:

</div>
1. **Permission enforcement works correctly** - Users/API keys can only access what they're allowed
2. **Tenant isolation is maintained** - Users from one tenant cannot access another tenant's resources
3. **Role-based access works** - Users with different roles get appropriate permissions
4. **API key permissions work** - API keys respect their assigned permissions
5. **Policy updates take effect** - Changes to permissions are reflected immediately
6. **Error handling** - Invalid requests are properly rejected and logged

<div style="background-color: #e8f5e9; border-left: 4px solid #4caf50; padding: 10px; margin: 15px 0; border-radius: 5px;">

### Test Scenarios: User-Level Enforcement

</div>

<div style="background-color: #fff3e0; border: 2px solid #ff9800; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 1: Admin User - Full Access (Role-Based)
**Setup:**
- Create user `alice` in `tenantA`
- Assign role `admin` to `alice`: `g, user:alice, tenantA, admin`
- Admin role has permissions: `p, admin, tenantA, users, create|read|update|delete|search`
- Admin role has permissions: `p, admin, tenantA, configurations, create|read|update|delete`
- Admin role has permissions: `p, admin, tenantA, dashboards, create|read|update|delete`
- Admin role has permissions: `p, admin, tenantA, alerts, create|read|update|delete`
- Admin role has permissions: `p, admin, tenantA, metrics, read|export`

**Validation Flow Tested:**
```
user:alice → role:admin → permissions → allowed
```

**Test Steps:**
1. Authenticate as `alice` → get JWT token
2. Try to access each resource with each action:
   - Create/read/update/delete/search users
   - Create/read/update/delete configurations
   - Create/read/update/delete dashboards
   - Create/read/update/delete alerts
   - Read/export metrics
3. Try to call ASR/TTS/NMT (read/inference) **without** API key

**Expected Result:**
- Management actions above: **ALLOWED** (HTTP 200/201)
- Service calls (ASR/TTS/NMT) without API key: **DENIED** (HTTP 401/403)

**What to Verify:**
- ✅ User → role lookup works (`g, user:alice, tenantA, admin`)
- ✅ Role → permissions lookup works (`p, admin, tenantA, users, read`)
- ✅ All admin operations succeed
- ✅ Service access is properly blocked (requires API key)
- ✅ Audit logs show "allow" decisions

</div>

<div style="background-color: #e3f2fd; border: 2px solid #2196f3; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 2: Regular User - Limited Access (Role-Based)
**Setup:**
- Create user `bob` in `tenantA`
- Assign role `user` to `bob`: `g, user:bob, tenantA, user`
- User role has only read permissions: `p, user, tenantA, users, read|search`
- User role has: `p, user, tenantA, configurations, read`
- User role has: `p, user, tenantA, dashboards, read`
- User role has: `p, user, tenantA, alerts, read`
- User role has: `p, user, tenantA, metrics, read`

**Validation Flow Tested:**
```
user:bob → role:user → permissions (read only) → allowed/denied
```

**Test Steps:**
1. Authenticate as `bob` → get JWT token
2. Try to read resources (users, configs, dashboards, alerts, metrics)
3. Try to create/update/delete resources
4. Try to access ASR/TTS/NMT (any action) without API key

**Expected Result:**
- Read operations: **ALLOWED** (HTTP 200)
- Create/update/delete operations: **DENIED** (HTTP 403)
- Service calls (ASR/TTS/NMT) without API key: **DENIED** (HTTP 401/403)

**What to Verify:**
- ✅ User → role lookup works (`g, user:bob, tenantA, user`)
- ✅ Role → permissions lookup works (`p, user, tenantA, users, read`)
- ✅ Read permissions work
- ✅ Write permissions are blocked (no `create|update|delete` in role)
- ✅ Service access is blocked
- ✅ Error messages are clear
- ✅ Audit logs show correct allow/deny decisions

</div>

<div style="background-color: #ffebee; border: 2px solid #f44336; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 3: Cross-Tenant Access Prevention
**Setup:**
- Create user `alice` in `tenantA` with admin role
- Create user `charlie` in `tenantB` with admin role
- Create resource `config1` in `tenantA`

**Test Steps:**
1. Authenticate as `charlie` (tenantB admin)
2. Try to access `config1` from `tenantA`

**Expected Result:** **DENIED** (HTTP 403 or 404)

**What to Verify:**
- ✅ Tenant isolation is enforced
- ✅ Users cannot access other tenants' resources
- ✅ Error message indicates permission denied or resource not found

</div>

<div style="background-color: #f3e5f5; border: 2px solid #9c27b0; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 4: User Without Role
**Setup:**
- Create user `dave` in `tenantA`
- Do NOT assign any role (no `g, user:dave, tenantA, role` entry)

**Validation Flow Tested:**
```
user:dave → roles (none) → permissions (none) → denied
```

**Test Steps:**
1. Authenticate as `dave` → get JWT token
2. Try to access any resource

**Expected Result:** All requests **DENIED** (HTTP 403)

**What to Verify:**
- ✅ User → role lookup returns empty (`g, user:dave, tenantA, role` → no results)
- ✅ No permissions found (no roles = no permissions)
- ✅ Users without roles cannot access anything
- ✅ Clear error message about missing permissions

</div>

<div style="background-color: #e1f5fe; border-left: 4px solid #03a9f4; padding: 10px; margin: 15px 0; border-radius: 5px;">

### Test Scenarios: API-Key-Level Enforcement

</div>

<div style="background-color: #e8f5e9; border: 2px solid #4caf50; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 5: API Key with Full Service Access (Direct Permissions)
**Setup:**
- Create API key `api_key_1` for `tenantA`
- Assign direct permissions:
  - `p, api_key_1, tenantA, asr, read`
  - `p, api_key_1, tenantA, asr, inference`
  - `p, api_key_1, tenantA, tts, read`
  - `p, api_key_1, tenantA, tts, inference`
  - `p, api_key_1, tenantA, nmt, read`
  - `p, api_key_1, tenantA, nmt, inference`

**Validation Flow Tested:**
```
api_key_1 → permissions → allowed
```

**Test Steps:**
1. Use API key `api_key_1` in request header
2. Try to access ASR, TTS, NMT services with read and inference actions

**Expected Result:** All service requests **ALLOWED** (HTTP 200)

**What to Verify:**
- ✅ API key authentication works
- ✅ Direct permission lookup works (`p, api_key_1, tenantA, asr, read`)
- ✅ No role lookup needed (direct permissions)
- ✅ Both read and inference work

</div>

<div style="background-color: #fff3e0; border: 2px solid #ff9800; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 6: API Key with Limited Permissions (Direct Permissions)
**Setup:**
- Create API key `api_key_2` for `tenantA`
- Assign only direct permission: `p, api_key_2, tenantA, asr, read` (no inference, no other services)

**Validation Flow Tested:**
```
api_key_2 → permissions (only asr.read) → allowed/denied
```

**Test Steps:**
1. Use API key `api_key_2` in request header
2. Try ASR read operation → should work
3. Try ASR inference operation → should fail (no permission)
4. Try TTS read operation → should fail (no permission)
5. Try TTS inference operation → should fail (no permission)

**Expected Result:**
- ASR read: **ALLOWED** (HTTP 200) - permission exists
- ASR inference: **DENIED** (HTTP 403) - no permission `p, api_key_2, tenantA, asr, inference`
- TTS operations: **DENIED** (HTTP 403) - no TTS permissions

**What to Verify:**
- ✅ Direct permission lookup works (`p, api_key_2, tenantA, asr, read`)
- ✅ Missing permissions are correctly denied
- ✅ Fine-grained permissions work
- ✅ API keys are restricted to assigned permissions only
- ✅ Error messages are clear

</div>

<div style="background-color: #ffebee; border: 2px solid #f44336; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 7: Expired/Inactive API Key
**Setup:**
- Create API key `key789` for `tenantA`
- Mark as inactive OR set expiration date in the past

**Test Steps:**
1. Use expired/inactive API key `key789` in request header
2. Try to access any service

**Expected Result:** **DENIED** (HTTP 401 or 403)

**What to Verify:**
- ✅ Expired keys are rejected
- ✅ Inactive keys are rejected
- ✅ Clear error message about key status

</div>

<div style="background-color: #f3e5f5; border: 2px solid #9c27b0; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 8: API Key Cross-Tenant Access
**Setup:**
- Create API key `key999` for `tenantA` with admin permissions
- Create resource in `tenantB`

**Test Steps:**
1. Use API key `key999` (tenantA) in request header
2. Try to access resource from `tenantB`

**Expected Result:** **DENIED** (HTTP 403)

**What to Verify:**
- ✅ API keys are tenant-scoped
- ✅ Cannot access other tenants' resources

</div>

<div style="background-color: #e1f5fe; border-left: 4px solid #03a9f4; padding: 10px; margin: 15px 0; border-radius: 5px;">

### Test Scenarios: Policy Updates

</div>

<div style="background-color: #fff9c4; border: 2px solid #fbc02d; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 9: Real-Time Policy Updates
**Setup:**
- User `alice` in `tenantA` with `user` role (read-only)
- Initially cannot create resources

**Test Steps:**
1. Authenticate as `alice` → try to create resource → should fail
2. Update policy: assign `admin` role to `alice` (via watcher/cache invalidation)
3. Wait for cache refresh (if applicable)
4. Try to create resource again

**Expected Result:**
- Before update: **DENIED** (HTTP 403)
- After update: **ALLOWED** (HTTP 201)

**What to Verify:**
- ✅ Policy changes take effect without service restart
- ✅ Cache invalidation works correctly
- ✅ Watcher mechanism updates policies in real-time

</div>

<div style="background-color: #ffebee; border-left: 4px solid #f44336; padding: 10px; margin: 15px 0; border-radius: 5px;">

### Test Scenarios: Error Handling

</div>

<div style="background-color: #fce4ec; border: 2px solid #e91e63; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 10: Invalid/Missing Subject
**Test Steps:**
1. Send request without authentication token
2. Send request with invalid/malformed token
3. Send request with non-existent user ID
V
**Expected Result:** **DENIED** (HTTP 401)

**What to Verify:**
- ✅ Unauthenticated requests are rejected
- ✅ Invalid tokens are rejected
- ✅ Clear error messages

</div>

<div style="background-color: #fff3e0; border: 2px solid #ff9800; padding: 15px; margin: 15px 0; border-radius: 5px;">

#### Test Case 11: Invalid Resource/Action
**Test Steps:**
1. Authenticate as valid user
2. Try to access non-existent resource (e.g., `invalid_resource`)
3. Try invalid action (e.g., `invalid_action`)

**Expected Result:** **DENIED** (HTTP 403 or 400)

**What to Verify:**
- ✅ Invalid resources are rejected
- ✅ Invalid actions are rejected
- ✅ Appropriate error codes returned

</div>

<div style="background-color: #e8f5e9; border: 3px solid #4caf50; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">

### Test Checklist Summary

**User-Level Testing (userId → roles → permissions → allowed/deny):**
- [ ] User → role lookup works correctly (`g, user_id, tenant, role`)
- [ ] Role → permissions lookup works correctly (`p, role, tenant, obj, act`)
- [ ] Admin user can access all resources (through admin role)
- [ ] Regular user has limited access (read-only through user role)
- [ ] Users without roles cannot access anything (no role = no permissions)
- [ ] Cross-tenant access is blocked (tenant isolation)
- [ ] Role hierarchy works (if implemented)
- [ ] Service calls (ASR/TTS/NMT) without API key are denied

**API-Key-Level Testing (api-key → permissions → allowed/deny):**
- [ ] Direct permission lookup works (`p, api_key_id, tenant, obj, act`)
- [ ] No role lookup needed (direct permissions only)
- [ ] API keys with full permissions work
- [ ] API keys with limited permissions are restricted
- [ ] Expired API keys are rejected
- [ ] Inactive API keys are rejected
- [ ] API keys are tenant-scoped
- [ ] Fine-grained service permissions work (e.g., `asr.read` but not `asr.inference`)

**Policy Management:**
- [ ] Policy updates take effect in real-time
- [ ] Cache invalidation works
- [ ] Watcher mechanism updates policies correctly

**Error Handling:**
- [ ] Invalid authentication is rejected
- [ ] Missing permissions return clear errors
- [ ] Invalid resources/actions are rejected
- [ ] Audit logs record all decisions

**Performance:**
- [ ] Permission checks are fast (< 10ms)
- [ ] Caching improves performance
- [ ] System handles high request volume

</div>

</div>

<div style="background-color: #e0f2f1; border: 2px solid #009688; padding: 20px; margin: 20px 0; border-radius: 8px;">

## Operational Notes
- Adapter: use Casbin Postgres adapter against `casbin_rule`.
- Watcher: use Redis (or equivalent) to invalidate enforcer cache on policy changes.
- Logging/metrics: record `(sub, dom, obj, act, decision)` for audit and observability.
- Caching: optionally warm per-tenant policy cache; keep cache TTL modest and rely on watcher for accuracy.

</div>
</body></html>
